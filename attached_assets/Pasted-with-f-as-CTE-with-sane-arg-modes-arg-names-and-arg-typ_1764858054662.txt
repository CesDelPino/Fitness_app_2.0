with
  f as (
    -- CTE with sane arg_modes, arg_names, and arg_types.
    -- All three are always of the same length.
    -- All three include all args, including OUT and TABLE args.
    with
      functions as (
        select
          *,
          -- proargmodes is null when all arg modes are IN
          coalesce(
            p.proargmodes,
            array_fill(
              $1::text,
              array[
                cardinality(coalesce(p.proallargtypes, p.proargtypes))
              ]
            )
          ) as arg_modes,
          -- proargnames is null when all args are unnamed
          coalesce(
            p.proargnames,
            array_fill(
              $2::text,
              array[
                cardinality(coalesce(p.proallargtypes, p.proargtypes))
              ]
            )
          ) as arg_names,
          -- proallargtypes is null when all arg modes are IN
          coalesce(p.proallargtypes, p.proargtypes) as arg_types,
          array_cat(
            array_fill($3, array[pronargs - pronargdefaults]),
            array_fill($4, array[pronargdefaults])
          ) as arg_has_defaults
        from
          pg_proc as p
        where
          p.prokind = $5
      )
    select
      f.oid as id,
      n.nspname as schema,
      f.proname as name,
      l.lanname as language,
      case
        when l.lanname = $6 then $7
        else f.prosrc
      end as definition,
      case
        when l.lanname = $8 then f.prosrc
        else pg_get_functiondef(f.oid)
      end as complete_statement,
      coalesce(f_args.args, $9) as args,
      pg_get_function_arguments(f.oid) as argument_types,
      pg_get_function_identity_arguments(f.oid) as identity_argument_types,
      f.prorettype as return_type_id,
      pg_get_function_result(f.oid) as return_type,
      nullif(rt.typrelid, $10) as return_type_relation_id,
      f.proretset as is_set_returning_function,
      case
        when f.provolatile = $11 then $12
        when f.provolatile = $13 then $14
        when f.provolatile = $15 then $16
      end as behavior,
      f.prosecdef as security_definer,
      f_config.config_params as config_params
    from
      functions f
      left join pg_namespace n on f.pronamespace = n.oid
      left join pg_language l on f.prolang = l.oid
      left join pg_type rt on rt.oid = f.prorettype
      left join (
        select
          oid,
          jsonb_object_agg(param, value) filter (
            where
              param is not null
          ) as config_params
        from
          (
            select
              oid,
              (string_to_array(unnest(proconfig), $17)) [$18] as param,
              (string_to_array(unnest(proconfig), $19)) [$20] as value
            from
              functions
          ) as t
        group by
          oid
      ) f_config on f_config.oid = f.oid
      left join (
        select
          oid,
          jsonb_agg(
            jsonb_build_object(
              $21,
              t2.mode,
              $22,
              name,
              $23,
              type_id,
              -- Cast null into false boolean
              $24,
              COALESCE(has_default, $25)
            )
          ) as args
        from
          (
            select
              oid,
              unnest(arg_modes) as mode,
              unnest(arg_names) as name,
              -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume
              -- integer, we need to cast it to be properly parsed
              unnest(arg_types)::int8 as type_id,
              unnest(arg_has_defaults) as has_default
            from
              functions
          ) as t1,
          lateral (
            select
              case
                when t1.mode = $26 then $27
                when t1.mode = $28 then $29
                when t1.mode = $30 then $31
                when t1.mode = $32 then $33
                else $34
              end as mode
          ) as t2
        group by
          t1.oid
      ) f_args on f_args.oid = f.oid
  )
select
  f.*
from
  f
where
  schema not in ($35, $36, $37)
  -- source: dashboard
  -- user: d312c300-6b0c-476b-81c3-6eeaec8915e9
  -- date: 2025-11-29T09:25:56.923Z